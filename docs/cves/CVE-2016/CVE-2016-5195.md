# CVE-2016-5195 Dirty Cow

## Description

The Dirty COW (CVE-2016-5195) vulnerability allows local users to gain root privileges on Linux systems.

低权限用户可以利用该漏洞写入对自身只读的内存页（包括可写文件系统上对该用户只读的文件）并提权至 root

该漏洞影响所有目前运行 Linux 系统的设备，包括但不限于运行 Linux 系统的服务器、Docker 容器服务、使用 Linux 操作系统的路由器、Android 手机/平板、搭载了 Android 系统的电视机/机顶盒等。

## 漏洞原理

- [Dirty COW](https://dirtycow.ninja/)
- [Dirty COW (CVE-2016-5195) - 漏洞详情](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails)
- [视频：Explaining Dirty COW local root exploit - CVE-2016-5195](https://www.youtube.com/embed/kEsshExn7aE)

<iframe width="560" height="315" src="https://www.youtube.com/embed/kEsshExn7aE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## 漏洞利用

[PoCs](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs){ .md-button }

### Table of PoCs
**Note**: if you experience crashes or locks take a look at [this](https://github.com/dirtycow/dirtycow.github.io/issues/25#issuecomment-255852675) fix.

| Link | Usage | Description | Family |
|:---:|:---:|:---:|:---:|
| [dirtyc0w.c](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c) | `./dirtyc0w file content` | Read-only write | /proc/self/mem |
| [cowroot.c](https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679) | `./cowroot` | SUID-based root | /proc/self/mem |
| [dirtycow-mem.c](https://gist.github.com/scumjr/17d91f20f73157c722ba2aea702985d2) | `./dirtycow-mem` | libc-based root | /proc/self/mem |
| [pokemon.c](https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c) | `./d file content` | Read-only write | PTRACE_POKEDATA |
| [dirtycow.cr](https://github.com/xlucas/dirtycow.cr) | `dirtycow --target --string --offset` | Read-only write | /proc/self/mem |
| [dirtyc0w.c](https://github.com/timwr/CVE-2016-5195) | `./dirtycow file content` | Read-only write (Android) | /proc/self/mem |
| [dirtycow.rb](https://github.com/rapid7/metasploit-framework/pull/7476) | `use exploit/linux/local/dirtycow` and `run` | SUID-based root | /proc/self/mem |
| [0xdeadbeef.c](https://github.com/scumjr/dirtycow-vdso) | `./0xdeadbeef` | vDSO-based root | PTRACE_POKEDATA |
| [naughtyc0w.c](https://gist.github.com/mak/c36136ccdbebf5ecfefd80c0f2ed6747) | `./c0w suid` | SUID-based root | /proc/self/mem |
| [c0w.c](https://gist.github.com/KrE80r/42f8629577db95782d5e4f609f437a54) | `./c0w` | SUID-based root | PTRACE_POKEDATA|
| [dirty_pass[...].c](https://gist.github.com/ngaro/05e084ca638340723b309cd304be77b2) | `./dirty_passwd_adjust_cow` | /etc/passwd based root | /proc/self/mem |
| [mucow.c](https://gist.github.com/chriscz/f1aca56cf15cfb7793db0141c15718cd) | `./mucow destination < payload.exe` | Read-only write (multi page) | PTRACE_POKEDATA |
| [cowpy.c](https://github.com/nowsecure/dirtycow) | `r2pm -i dirtycow` | Read-only write (radare2) | /proc/self/mem |
| [dirtycow.fasm](https://github.com/sivizius/dirtycow.fasm) | `./main` | SUID-based root | /proc/self/mem |
| [dcow.cpp](https://github.com/gbonacini/CVE-2016-5195) | `./dcow` | /etc/passwd based root | /proc/self/mem |
| [dirtyc0w.go](https://github.com/mengzhuo/dirty-cow-golang/blob/master/dirtyc0w.go) | `go run dirtyc0w.go -f=file -c=content` | Read-only write | /proc/self/mem |
| [dirty.c](https://github.com/FireFart/dirtycow/blob/master/dirty.c) | `./dirty` | /etc/passwd based root | PTRACE_POKEDATA |

### List of PoCs

* Allows user to write on files meant to be read only. [Link](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)
* Gives the user root by overwriting `/usr/bin/passwd` or a suid binary. [Link](https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679)
* Gives the user root by patching libc's getuid call and invoking `su`.[Link](https://gist.github.com/scumjr/17d91f20f73157c722ba2aea702985d2)
* Allows user to write on files meant to be read only. [Link](https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c)
* Allows a user to write on files meant to be read only. [Link](https://github.com/xlucas/dirtycow.cr)
* Allows user to write on files meant to be read only (android). [Link](https://github.com/timwr/CVE-2016-5195)
* Metasploit module based on the `cowroot` PoC. [Link](https://github.com/rapid7/metasploit-framework/pull/7476)
* Gives the user root by patching the vDSO escapes containers/SELinux doesn't need suid. [Link](https://github.com/scumjr/dirtycow-vdso)
* Gives the user root by injecting shellcode into a SUID file. [Link](https://gist.github.com/mak/c36136ccdbebf5ecfefd80c0f2ed6747)
* Gives the user root by injecting shellcode into a SUID file using PTRACE_POKEDATA . [Link](https://gist.github.com/KrE80r/42f8629577db95782d5e4f609f437a54)
* Gives the user root by replacing /etc/passwd [Link](https://gist.github.com/ngaro/05e084ca638340723b309cd304be77b2)
* Allows user to write on files meant to be read only. Supports writing to multiple pages, not just the first [Link](https://gist.github.com/chriscz/f1aca56cf15cfb7793db0141c15718cd)
* Allows the user to write on files meant to be read only, implemented as a radare2 IO plugin. [Link](https://github.com/nowsecure/dirtycow)
* Gives the user root by injecting shellcode into a SUID file. implemented for amd64 in flatassembly. [Link](https://github.com/sivizius/dirtycow.fasm)
* Gives the user root by replacing /etc/passwd [Link](https://github.com/gbonacini/CVE-2016-5195)
* Allows user to write on files meant to be read only. implemented for arm32/x86/amd64 in Golang faster than c implement. [Link](https://github.com/mengzhuo/dirty-cow-golang/blob/master/dirtyc0w.go)
* Generates a new password hash on the fly and modifies /etc/passwd automatically. Just run and pwn. [Link](https://github.com/FireFart/dirtycow/blob/master/dirty.c)

## 漏洞修复

检测您的系统是否存在脏牛漏洞，如果存在，建议您尽快升级内核版本。

[检测脚本](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c){ .md-button }

### 免重启热修补

由于该漏洞位于 Linux 内核，发行版官方的内核更新只有在重启后才能生效。如果您的线上业务不能中断，可以采用下面这种基于 `systemtap` 的热修补方法，并在合适的时候更新系统内核。

systemtap 是一款内核调试、性能分析工具，其原理是插入新的内核模块并根据需要修改逻辑，实现功能。该工具同样可以被用于安全应急响应，在不重启系统的前提下修补安全漏洞或者提高利用难度。

针对 CVE-2016-5195 的 systemtap 热修补补丁最先出现在 Red Hat 公司 Bug 追踪系统的讨论区（出处），内容节选如下：

```c
probe kernel.function("mem_write").call ? { $count = 0 }
probe syscall.ptrace { $request = 0xfff }
```

!!! warning "注意"
    
    该补丁仅适用于 64 位系统，且需要安装 systemtap 工具。
    通过阻止写入 `/proc/self/mem` 来达到阻止上述利用代码的目的。该补丁有较为明显的副作用：无法调试程序，还可能导致 RHEL/CentOS 6 和 Ubuntu 14.04 上使用的 upstart 服务管理机制不能正常工作。

本文提供另一种热修补方式，代码如下：

```c
probe kernel.function("sys_madvise") {
    if ($behavior == 4) { $behavior = 0 }
}
```

#### Ubuntu系统前置步骤

```bash
# apt-get install gcc systemtap
# ddeb_filename=$(dpkg-query --show --showformat='${Package}-dbgsym_${Version}_${Architecture}.ddeb' linux-image-$(uname -r))
# wget http://ddebs.ubuntu.com/pool/main/l/linux/${ddeb_filename}
# dpkg -i ${ddeb_filename}
```

#### Debian系统前置步骤

由于 Debian 系统在同一包名下存在多个版本，需要从 snapshot 镜像下载或者自己编译得到调试信息，这里从略

#### RHEL/CentOS系统安装步骤
```bash
# yum install systemtap
```

现在需要安装与正在运行的内核版本相同的头文件和调试信息，主要是以下几个包：

```bash
1. `kernel-devel-$(uname -r)`
2. `kernel-debuginfo-common-$(arch)-$(uname -r)`
3. `kernel-debuginfo-$(uname -r)`
```

可以手工搜索相应的包名，下载 rpm 并安装（请尽量从官方源下载，使用错误的包可能导致内核崩溃）

测试systemtap安装成功：

```bash
# stap -e 'probe begin { print("hello world\n"); exit(); }'
hello world
```

执行热修补

```bash
# stap -Fge 'probe kernel.function("sys_madvise") { if ($behavior == 4) { $behavior = 0 }}'
 
Disconnecting from systemtap module.
To reconnect, type "staprun -A stap_9f8ce8307eb418da7c981b3223eec678_12644"
```

修补完成

```bash
# lsmod | grep stap
stap_9f8ce8307eb418da7c981b3223eec678_12644    81920  0
```

可以看到 systemtap 编译出的内核模块已经成功加载。


- [无需重启，修复横扫Linux系统的脏牛本地提权漏洞 (CVE-2016-5195)](https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651370571&idx=1&sn=68acf07ca2683a9c98fa52e900d97db3&chksm=8d39c5c3ba4e4cd58c21d0a21ca337ded2132625987e174d286f8d175034267bd09807ea9a11&scene=4#wechat_redirect)